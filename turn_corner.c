#pragma config(Sensor, S1,     sonar,          sensorSONAR)
#pragma config(Sensor, S2,     touch,          sensorTouch)
#pragma config(Sensor, S3,     light,          sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()
{
	int ssv, tsv, lsv;			//set variables

	while(1) {
		ssv = SensorValue[sonar];		//set variables
		tsv = SensorValue[touch];
		lsv = SensorValue[light];
		nxtDisplayTextLine(2, "%d cm", ssv);

		if((ssv >= 5) && (ssv <= 30)) {		// distance to wall is 5cm< ssv <10cm
			motor[motorB] = 5;
			motor[motorC] = 5;
		}
		if((ssv > 30)&&(ssv <=255)) {								// distance to right wall over 10cm then turn right
			nMotorEncoder[motorB] = 0;
			nMotorEncoder[motorC] = 0;
			while(nMotorEncoder[motorB]< 273.913 && nMotorEncoder[motorC] <635.2174){
				motor[motorB] = 10;
				motor[motorC] = 24.25;
			}
			nMotorEncoder[motorB] = 0;
			nMotorEncoder[motorC] = 0;
			motor[motorB] = 10;
			motor[motorC] = 10;
			wait1Msec(2000);
		}
		if((ssv <5)&&(ssv>=0)) {								// when distance to right wall under 5cm then turn left
			nMotorEncoder[motorB] = 0;
			nMotorEncoder[motorC] = 0;
			while(nMotorEncoder[motorB]< 635.2174 && nMotorEncoder[motorC] <273.913) {
				motor[motorB] = 24.25;
				motor[motorC] = 10;
			}
			nMotorEncoder[motorB] = 0;
			nMotorEncoder[motorC] = 0;
			motor[motorB] = 10;
			motor[motorC] = 10;
			wait1Msec(2000);
		}
		if(tsv == 1) {			//  There is touch
			bFloatDuringInactiveMotorPWM = false;
			wait1Msec(1000);
			motor[motorB] = -60;
			motor[motorC] = -60;
			wait1Msec(2000);
			bFloatDuringInactiveMotorPWM = false;
			wait1Msec(1000);
			motor[motorB] = 40;
			motor[motorC] = -40;
			wait1Msec(800);
		}
		if(lsv < 0) {   // There is low level light
			motor[motorB] = 0;
			motor[motorC] = 0;
			bFloatDuringInactiveMotorPWM = false;
		}
	}
}
